<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/feat/2d/Kanade.js - igata.js API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="igata.js API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Affine2d.html">Affine2d</a></li>
                                <li><a href="../classes/Bbf.html">Bbf</a></li>
                                <li><a href="../classes/Bitmap.html">Bitmap</a></li>
                                <li><a href="../classes/Blur.html">Blur</a></li>
                                <li><a href="../classes/Brightness.html">Brightness</a></li>
                                <li><a href="../classes/Cache.html">Cache</a></li>
                                <li><a href="../classes/Calc.html">Calc</a></li>
                                <li><a href="../classes/Cascade.html">Cascade</a></li>
                                <li><a href="../classes/Convolution.html">Convolution</a></li>
                                <li><a href="../classes/Data_t.html">Data_t</a></li>
                                <li><a href="../classes/Estimator.html">Estimator</a></li>
                                <li><a href="../classes/FastCorner.html">FastCorner</a></li>
                                <li><a href="../classes/Filter.html">Filter</a></li>
                                <li><a href="../classes/Grayscale.html">Grayscale</a></li>
                                <li><a href="../classes/Haar.html">Haar</a></li>
                                <li><a href="../classes/HomoGraphy2d.html">HomoGraphy2d</a></li>
                                <li><a href="../classes/Igata.html">Igata</a></li>
                                <li><a href="../classes/Invert.html">Invert</a></li>
                                <li><a href="../classes/IVector.html">IVector</a></li>
                                <li><a href="../classes/Kanade.html">Kanade</a></li>
                                <li><a href="../classes/Keypoint_t.html">Keypoint_t</a></li>
                                <li><a href="../classes/LA.html">LA</a></li>
                                <li><a href="../classes/lev_table_t.html">lev_table_t</a></li>
                                <li><a href="../classes/LinearAlgebra.html">LinearAlgebra</a></li>
                                <li><a href="../classes/Matrix_t.html">Matrix_t</a></li>
                                <li><a href="../classes/MatrixMath.html">MatrixMath</a></li>
                                <li><a href="../classes/MM.html">MM</a></li>
                                <li><a href="../classes/MotionEstimator.html">MotionEstimator</a></li>
                                <li><a href="../classes/Node_t.html">Node_t</a></li>
                                <li><a href="../classes/Orb.html">Orb</a></li>
                                <li><a href="../classes/perform_one_point.html">perform_one_point</a></li>
                                <li><a href="../classes/Processing.html">Processing</a></li>
                                <li><a href="../classes/Pyramid_t.html">Pyramid_t</a></li>
                                <li><a href="../classes/Ransac_t.html">Ransac_t</a></li>
                                <li><a href="../classes/Sepia.html">Sepia</a></li>
                                <li><a href="../classes/Stack.html">Stack</a></li>
                                <li><a href="../classes/Table_t.html">Table_t</a></li>
                                <li><a href="../classes/Threshold.html">Threshold</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Yape.html">Yape</a></li>
                                <li><a href="../classes/Yape06.html">Yape06</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Feat.html">Feat</a></li>
                                <li><a href="../modules/Igata.html">Igata</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/feat/2d/Kanade.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
///**
// * license inazumatv.com
// * author (at)taikiken / http://inazumatv.com
// * date 15/09/10 - 16:52
// *
// * Copyright (c) 2011-2015 inazumatv.com, inc.
// *
// * Distributed under the terms of the MIT license.
// * http://www.opensource.org/licenses/mit-license.html
// *
// * This notice shall be included in all copies or substantial portions of the Software.
// *
// * for igata.js
// */
/*jslint -W016*/
/**
 * original code
 * http://inspirit.github.io/jsfeat/
 *
 * @module Igata
 * @submodule Feat
 */
( function ( window ) {

  &#x27;use strict&#x27;;

  var
    Igata = window.Igata,
    global = Igata;


  global.Kanade = ( function () {
    
    var Cache = global.Cache;
    var Matrix_t = global.Matrix_t;

    var scharr_deriv = global.Processing.scharrDerivatives;

    /**
     * Calculates an optical flow for a sparse feature set using the iterative Lucas-Kanade method with pyramids.
     *
     * @class Kanade
     * @static
     * @constructor
     */
    function Kanade () {
      throw new Error( &#x27;Kanade can\&#x27;t create instance.&#x27; );
    }

    var p = Kanade.prototype;
    p.constructor = Kanade;

    /**
     * @method track
     * @static
     *
     * @param {Pyramid_t} prev_pyr previous frame 8-bit pyramid_t
     * @param {Pyramid_t} curr_pyr current frame 8-bit pyramid_t
     * @param {Array} prev_xy Array of 2D coordinates for which the flow needs to be found
     * @param {Array} curr_xy Array of 2D coordinates containing the calculated new positions
     * @param {number} count number of input coordinates
     * @param {number} win_size size of the search window at each pyramid level
     * @param {number=30} [max_iter] stop searching after the specified maximum number of iterations
     * @param {Uint8Array} [status] each element is set to 1 if the flow for the corresponding features has been found overwise 0
     * @param {number=0.01} [eps] stop searching when the search window moves by less than eps
     * @param {number=0.0001} [min_eigen_threshold] the algorithm calculates the minimum eigen value of a 2x2 normal matrix of optical flow equations, divided by number of pixels in a window; if this value is less than min_eigen_threshold, then a corresponding feature is filtered out and its flow is not processed, it allows to remove bad points and get a performance boost
     */
    Kanade.track = function ( prev_pyr, curr_pyr, prev_xy, curr_xy, count, win_size, max_iter, status, eps, min_eigen_threshold ) {

      if (typeof max_iter === &quot;undefined&quot;) { max_iter = 30; }
      if (typeof status === &quot;undefined&quot;) { status = new Uint8Array(count); }
      if (typeof eps === &quot;undefined&quot;) { eps = 0.01; }
      if (typeof min_eigen_threshold === &quot;undefined&quot;) { min_eigen_threshold = 0.0001; }

      var half_win = (win_size-1)*0.5;
      var win_area = (win_size*win_size)|0;
      var win_area2 = win_area &lt;&lt; 1;
      var prev_imgs = prev_pyr.data, next_imgs = curr_pyr.data;
      var img_prev=prev_imgs[0].data,img_next=next_imgs[0].data;
      var w0 = prev_imgs[0].cols, h0 = prev_imgs[0].rows,lw=0,lh=0;

      var iwin_node = Cache.getBuffer(win_area&lt;&lt;2);
      var deriv_iwin_node = Cache.getBuffer(win_area2&lt;&lt;2);
      var deriv_lev_node = Cache.getBuffer((h0*(w0&lt;&lt;1))&lt;&lt;2);

      var deriv_m = new Matrix_t(w0, h0, Igata.S32C2_t, deriv_lev_node.data);

      var iwin_buf = iwin_node.i32;
      var deriv_iwin = deriv_iwin_node.i32;
      var deriv_lev = deriv_lev_node.i32;

      var dstep=0,src=0,dsrc=0,iptr=0,diptr=0,jptr=0;
      var lev_sc=0.0,prev_x=0.0,prev_y=0.0,next_x=0.0,next_y=0.0;
      var prev_delta_x=0.0,prev_delta_y=0.0,delta_x=0.0,delta_y=0.0;
      var iprev_x=0,iprev_y=0,inext_x=0,inext_y=0;
      var i=0,j=0,x=0,y=0,level=0,ptid=0,iter=0;
      var brd_tl=0,brd_r=0,brd_b=0;
      var a=0.0,b=0.0,b1=0.0,b2=0.0;

      // fixed point math
      var W_BITS14 = 14;
      var W_BITS4 = 14;
      var W_BITS1m5 = W_BITS4 - 5;
      var W_BITS1m51 = (1 &lt;&lt; ((W_BITS1m5) - 1));
      var W_BITS14_ = (1 &lt;&lt; W_BITS14);
      var W_BITS41 = (1 &lt;&lt; ((W_BITS4) - 1));
      var FLT_SCALE = 1.0/(1 &lt;&lt; 20);
      var iw00=0,iw01=0,iw10=0,iw11=0,ival=0,ixval=0,iyval=0;
      var A11=0.0,A12=0.0,A22=0.0,D=0.0,min_eig=0.0;

      var FLT_EPSILON = 0.00000011920929;
      eps *= eps;

      // reset status
      for (; i &lt; count; ++i) {
        
        status[i] = 1;
        
      }

      var max_level = (prev_pyr.levels - 1)|0;
      level = max_level;

      for (; level &gt;= 0; --level) {
        
        lev_sc = (1.0/(1 &lt;&lt; level));
        lw = w0 &gt;&gt; level;
        lh = h0 &gt;&gt; level;
        dstep = lw &lt;&lt; 1;
        img_prev = prev_imgs[level].data;
        img_next = next_imgs[level].data;

        brd_r = (lw - win_size)|0;
        brd_b = (lh - win_size)|0;

        // calculate level derivatives
        scharr_deriv(prev_imgs[level], deriv_m);

        // iterate through points
        for (ptid = 0; ptid &lt; count; ++ptid) {
          
          i = ptid &lt;&lt; 1;
          j = i + 1;
          prev_x = prev_xy[i]*lev_sc;
          prev_y = prev_xy[j]*lev_sc;

          if( level === max_level ) {
            
            next_x = prev_x;
            next_y = prev_y;
            
          } else {
            
            next_x = curr_xy[i]*2.0;
            next_y = curr_xy[j]*2.0;
            
          }
          
          curr_xy[i] = next_x;
          curr_xy[j] = next_y;

          prev_x -= half_win;
          prev_y -= half_win;
          iprev_x = prev_x|0;
          iprev_y = prev_y|0;

          // border check
          x = (iprev_x &lt;= brd_tl)|(iprev_x &gt;= brd_r)|(iprev_y &lt;= brd_tl)|(iprev_y &gt;= brd_b);
          
          if ( x !== 0 ) {
            
            if ( level === 0 ) {
              
              status[ptid] = 0;
              
            }
            
            continue;
            
          }

          a = prev_x - iprev_x;
          b = prev_y - iprev_y;
          iw00 = (((1.0 - a)*(1.0 - b)*W_BITS14_) + 0.5)|0;
          iw01 = ((a*(1.0 - b)*W_BITS14_) + 0.5)|0;
          iw10 = (((1.0 - a)*b*W_BITS14_) + 0.5)|0;
          iw11 = (W_BITS14_ - iw00 - iw01 - iw10);

          A11 = 0.0;
          A12 = 0.0;
          A22 = 0.0;

          // extract the patch from the first image, compute covariation matrix of derivatives
          for ( y = 0; y &lt; win_size; ++y ) {
            
            src = ( (y + iprev_y)*lw + iprev_x )|0;
            dsrc = src &lt;&lt; 1;

            iptr = (y*win_size)|0;
            diptr = iptr &lt;&lt; 1;
            
            for (x = 0 ; x &lt; win_size; ++x, ++src, ++iptr, dsrc += 2) {
              
              ival = ( (img_prev[src])*iw00 + (img_prev[src+1])*iw01 + (img_prev[src+lw])*iw10 + (img_prev[src+lw+1])*iw11 );
              ival = (((ival) + W_BITS1m51) &gt;&gt; (W_BITS1m5));

              ixval = ( deriv_lev[dsrc]*iw00 + deriv_lev[dsrc+2]*iw01 + deriv_lev[dsrc+dstep]*iw10 + deriv_lev[dsrc+dstep+2]*iw11 );
              ixval = (((ixval) + W_BITS41) &gt;&gt; (W_BITS4));

              iyval = ( deriv_lev[dsrc+1]*iw00 + deriv_lev[dsrc+3]*iw01 + deriv_lev[dsrc+dstep+1]*iw10 + deriv_lev[dsrc+dstep+3]*iw11 );
              iyval = (((iyval) + W_BITS41) &gt;&gt; (W_BITS4));

              iwin_buf[iptr] = ival;
              deriv_iwin[diptr++] = ixval;
              deriv_iwin[diptr++] = iyval;

              A11 += ixval*ixval;
              A12 += ixval*iyval;
              A22 += iyval*iyval;
              
            }
            
          }

          A11 *= FLT_SCALE; A12 *= FLT_SCALE; A22 *= FLT_SCALE;

          D = A11*A22 - A12*A12;
          min_eig = (A22 + A11 - Math.sqrt((A11-A22)*(A11-A22) + 4.0*A12*A12)) / win_area2;

          if ( min_eig &lt; min_eigen_threshold || D &lt; FLT_EPSILON ) {
            
            if ( level === 0 ) {
              
              status[ptid] = 0;
              
            }
            
            continue;
            
          }

          D = 1.0/D;

          next_x -= half_win;
          next_y -= half_win;
          prev_delta_x = 0.0;
          prev_delta_y = 0.0;

          for ( iter = 0; iter &lt; max_iter; ++iter ) {
            
            inext_x = next_x|0;
            inext_y = next_y|0;

            x = (inext_x &lt;= brd_tl)|(inext_x &gt;= brd_r)|(inext_y &lt;= brd_tl)|(inext_y &gt;= brd_b);
            
            if ( x !== 0 ) {
              
              if ( level === 0 ) {
                
                status[ptid] = 0;
                
              }
              
              break;
              
            }

            a = next_x - inext_x;
            b = next_y - inext_y;
            iw00 = (((1.0 - a)*(1.0 - b)*W_BITS14_) + 0.5)|0;
            iw01 = ((a*(1.0 - b)*W_BITS14_) + 0.5)|0;
            iw10 = (((1.0 - a)*b*W_BITS14_) + 0.5)|0;
            iw11 = (W_BITS14_ - iw00 - iw01 - iw10);
            b1 = 0.0;
            b2 = 0.0;

            for ( y = 0; y &lt; win_size; ++y ) {
              
              jptr = ( (y + inext_y)*lw + inext_x )|0;

              iptr = (y*win_size)|0;
              diptr = iptr &lt;&lt; 1;
              
              for ( x = 0 ; x &lt; win_size; ++x, ++jptr, ++iptr ) {
                
                ival = ( (img_next[jptr])*iw00 + (img_next[jptr+1])*iw01 + (img_next[jptr+lw])*iw10 + (img_next[jptr+lw+1])*iw11 );
                ival = (((ival) + W_BITS1m51) &gt;&gt; (W_BITS1m5));
                ival = (ival - iwin_buf[iptr]);

                b1 += ival * deriv_iwin[diptr++];
                b2 += ival * deriv_iwin[diptr++];
                
              }
              
            }

            b1 *= FLT_SCALE;
            b2 *= FLT_SCALE;

            delta_x = ((A12*b2 - A22*b1) * D);
            delta_y = ((A12*b1 - A11*b2) * D);

            next_x += delta_x;
            next_y += delta_y;
            curr_xy[i] = next_x + half_win;
            curr_xy[j] = next_y + half_win;

            if ( delta_x*delta_x + delta_y*delta_y &lt;= eps ) {
              
              break;
              
            }

            if ( iter &gt; 0 &amp;&amp; Math.abs(delta_x + prev_delta_x) &lt; 0.01 &amp;&amp; Math.abs(delta_y + prev_delta_y) &lt; 0.01 ) {
              
              curr_xy[i] -= delta_x*0.5;
              curr_xy[j] -= delta_y*0.5;
              break;
              
            }

            prev_delta_x = delta_x;
            prev_delta_y = delta_y;
            
          }
          
        } // points loop
        
      } // levels loop

      Cache.putBuffer(iwin_node);
      Cache.putBuffer(deriv_iwin_node);
      Cache.putBuffer(deriv_lev_node);
      
    };

    return Kanade;

  }() );

}( window ) );
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
