<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/feat/math/LinearAlgebra.js - igata.js API</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="igata.js API" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Affine2d.html">Affine2d</a></li>
                                <li><a href="../classes/Angle.html">Angle</a></li>
                                <li><a href="../classes/Bbf.html">Bbf</a></li>
                                <li><a href="../classes/Bitmap.html">Bitmap</a></li>
                                <li><a href="../classes/Blur.html">Blur</a></li>
                                <li><a href="../classes/Brightness.html">Brightness</a></li>
                                <li><a href="../classes/Cache.html">Cache</a></li>
                                <li><a href="../classes/Calc.html">Calc</a></li>
                                <li><a href="../classes/Cascade.html">Cascade</a></li>
                                <li><a href="../classes/Convolution.html">Convolution</a></li>
                                <li><a href="../classes/Data_t.html">Data_t</a></li>
                                <li><a href="../classes/Estimator.html">Estimator</a></li>
                                <li><a href="../classes/FastCorner.html">FastCorner</a></li>
                                <li><a href="../classes/Filter.html">Filter</a></li>
                                <li><a href="../classes/Grayscale.html">Grayscale</a></li>
                                <li><a href="../classes/Haar.html">Haar</a></li>
                                <li><a href="../classes/HomoGraphy2d.html">HomoGraphy2d</a></li>
                                <li><a href="../classes/Igata.html">Igata</a></li>
                                <li><a href="../classes/Invert.html">Invert</a></li>
                                <li><a href="../classes/IVector.html">IVector</a></li>
                                <li><a href="../classes/Kanade.html">Kanade</a></li>
                                <li><a href="../classes/Keypoint_t.html">Keypoint_t</a></li>
                                <li><a href="../classes/LA.html">LA</a></li>
                                <li><a href="../classes/lev_table_t.html">lev_table_t</a></li>
                                <li><a href="../classes/LinearAlgebra.html">LinearAlgebra</a></li>
                                <li><a href="../classes/Matrix_t.html">Matrix_t</a></li>
                                <li><a href="../classes/MatrixMath.html">MatrixMath</a></li>
                                <li><a href="../classes/MM.html">MM</a></li>
                                <li><a href="../classes/MotionEstimator.html">MotionEstimator</a></li>
                                <li><a href="../classes/Node_t.html">Node_t</a></li>
                                <li><a href="../classes/Orb.html">Orb</a></li>
                                <li><a href="../classes/perform_one_point.html">perform_one_point</a></li>
                                <li><a href="../classes/Processing.html">Processing</a></li>
                                <li><a href="../classes/Pyramid_t.html">Pyramid_t</a></li>
                                <li><a href="../classes/Ransac_t.html">Ransac_t</a></li>
                                <li><a href="../classes/Sepia.html">Sepia</a></li>
                                <li><a href="../classes/Stack.html">Stack</a></li>
                                <li><a href="../classes/Table_t.html">Table_t</a></li>
                                <li><a href="../classes/Threshold.html">Threshold</a></li>
                                <li><a href="../classes/Vector2.html">Vector2</a></li>
                                <li><a href="../classes/Vector3.html">Vector3</a></li>
                                <li><a href="../classes/Yape.html">Yape</a></li>
                                <li><a href="../classes/Yape06.html">Yape06</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Feat.html">Feat</a></li>
                                <li><a href="../modules/Igata.html">Igata</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/feat/math/LinearAlgebra.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
///**
// * license inazumatv.com
// * author (at)taikiken / http://inazumatv.com
// * date 15/09/09 - 13:23
// *
// * Copyright (c) 2011-2015 inazumatv.com, inc.
// *
// * Distributed under the terms of the MIT license.
// * http://www.opensource.org/licenses/mit-license.html
// *
// * This notice shall be included in all copies or substantial portions of the Software.
// *
// * for igata.js
// */
/*jslint -W016*/
/**
 * original code
 * http://inspirit.github.io/Igata/
 *
 * @module Igata
 * @submodule Feat
 */
( function ( window ) {

  &#x27;use strict&#x27;;

  var
    Igata = window.Igata,
    global = Igata;


  var LinearAlgebra = ( function () {

    var Cache = global.Cache;
    var Matrix_t = global.Matrix_t;
    var MM = global.MM;

    var _abs = global._abs;
    var _sqrt = global._sqrt;
    var _max = global._max;

    // ---------------------------------------------------
    // private static method
    // ---------------------------------------------------

    // swap
    /**
     * @for LinearAlgebra
     * @method swap
     * @private
     * @static
     *
     * @param {Matrix_t} A
     * @param {number} i0
     * @param {number} i1
     * @param {Matrix_t} [t]
     */
    function swap ( A, i0, i1, t ) {

      t = A[i0];
      A[i0] = A[i1];
      A[i1] = t;

    }

    /**
     * @for LinearAlgebra
     * @method hypot
     * @private
     * @static
     *
     * @param {number} a
     * @param {number} b
     * @return {number}
     */
    function hypot (a, b) {

      a = _abs(a);
      b = _abs(b);

      if (  a &gt; b ) {

        b /= a;
        return a*_sqrt(1.0 + b*b);

      }

      if (  b &gt; 0 ) {

        a /= b;
        return b*_sqrt(1.0 + a*a);

      }

      return 0.0;

    }

    // jacobiImpl
    /**
     * @for LinearAlgebra
     * @method jacobiImpl
     * @private
     * @static
     *
     * @param {Matrix_t} A
     * @param {number} astep
     * @param {Matrix_t} W
     * @param {Matrix_t} V
     * @param {number} vstep
     * @param {number} n
     * @constructor
     */
    function jacobiImpl ( A, astep, W, V, vstep, n ) {

      var eps = Igata.EPSILON;
      var i=0,j=0,k=0,m=0,l=0,idx=0,_in=0,_in2=0;
      var iters=0,max_iter=n*n*30;
      var mv=0.0,val=0.0,p=0.0,y=0.0,t=0.0,s=0.0,c=0.0,a0=0.0,b0=0.0;

      var indR_buff = Cache.getBuffer(n&lt;&lt;2);
      var indC_buff = Cache.getBuffer(n&lt;&lt;2);
      var indR = indR_buff.i32;
      var indC = indC_buff.i32;

      if ( V) {

        for (; i &lt; n; i++) {

          k = i*vstep;

          for (j = 0; j &lt; n; j++) {

            V[k + j] = 0.0;

          }

          V[k + i] = 1.0;

        }

      }

      for (k = 0; k &lt; n; k++) {

        W[k] = A[(astep + 1)*k];

        if ( k &lt; n - 1) {

          for (m = k+1, mv = _abs(A[astep*k + m]), i = k+2; i &lt; n; i++) {

            val = _abs(A[astep*k+i]);

            if ( mv &lt; val){

              mv = val;
              m = i;

            }

          }

          indR[k] = m;

        }

        if ( k &gt; 0) {

          for (m = 0, mv = _abs(A[k]), i = 1; i &lt; k; i++) {

            val = _abs(A[astep*i+k]);

            if ( mv &lt; val){

              mv = val;
              m = i;

            }

          }

          indC[k] = m;

        }

      }

      if ( n &gt; 1) {

        for ( ; iters &lt; max_iter; iters++) {

          // find index (k,l) of pivot p
          for (k = 0, mv = _abs(A[indR[0]]), i = 1; i &lt; n-1; i++) {

            val = _abs(A[astep*i + indR[i]]);

            if (  mv &lt; val ){

              mv = val;
              k = i;

            }

          }

          l = indR[k];

          for (i = 1; i &lt; n; i++) {

            val = _abs(A[astep*indC[i] + i]);

            if (  mv &lt; val ){

              mv = val;
              k = indC[i];
              l = i;

            }

          }

          p = A[astep*k + l];

          if ( _abs(p) &lt;= eps ) {

            break;

          }

          y = (W[l] - W[k])*0.5;
          t = _abs(y) + hypot(p, y);
          s = hypot(p, t);
          c = t/s;
          s = p/s; t = (p/t)*p;

          if ( y &lt; 0){

            s = -s;
            t = -t;

          }

          A[astep*k + l] = 0;

          W[k] -= t;
          W[l] += t;

          // rotate rows and columns k and l
          for (i = 0; i &lt; k; i++) {

            _in = (astep * i + k);
            _in2 = (astep * i + l);
            a0 = A[_in];
            b0 = A[_in2];
            A[_in] = a0 * c - b0 * s;
            A[_in2] = a0 * s + b0 * c;

          }

          for (i = (k + 1); i &lt; l; i++) {

            _in = (astep * k + i);
            _in2 = (astep * i + l);
            a0 = A[_in];
            b0 = A[_in2];
            A[_in] = a0 * c - b0 * s;
            A[_in2] = a0 * s + b0 * c;

          }

          i = l + 1;
          _in = (astep * k + i);
          _in2 = (astep * l + i);

          for (; i &lt; n; i++, _in++, _in2++) {

            a0 = A[_in];
            b0 = A[_in2];
            A[_in] = a0 * c - b0 * s;
            A[_in2] = a0 * s + b0 * c;

          }

          // rotate eigenvectors
          if (V) {

            _in = vstep * k;
            _in2 = vstep * l;

            for (i = 0; i &lt; n; i++, _in++, _in2++) {

              a0 = V[_in];
              b0 = V[_in2];
              V[_in] = a0 * c - b0 * s;
              V[_in2] = a0 * s + b0 * c;

            }

          }


          for (j = 0; j &lt; 2; j++) {

            idx = j === 0 ? k : l;

            if ( idx &lt; n - 1) {

              for (m = idx+1, mv = _abs(A[astep*idx + m]), i = idx+2; i &lt; n; i++) {

                val = _abs(A[astep*idx+i]);

                if (  mv &lt; val ){

                  mv = val;
                  m = i;

                }

              }

              indR[idx] = m;

            }

            if ( idx &gt; 0) {

              for (m = 0, mv = _abs(A[idx]), i = 1; i &lt; idx; i++) {

                val = _abs(A[astep*i+idx]);

                if (  mv &lt; val ){

                  mv = val;
                  m = i;

                }

              }

              indC[idx] = m;

            }

          }

        }

      }// n &gt; 1

      // sort eigenvalues &amp; eigenvectors
      for (k = 0; k &lt; n-1; k++) {

        m = k;

        for (i = k+1; i &lt; n; i++) {

          if (W[m] &lt; W[i]) {

            m = i;

          }

        }

        if ( k !== m) {

          swap(W, m, k, mv);

          if ( V) {

            for (i = 0; i &lt; n; i++) {

              swap(V, vstep*m + i, vstep*k + i, mv);

            }

          }

        }

      }

      Cache.putBuffer( indR_buff );
      Cache.putBuffer( indC_buff );

    }

    // jacobiSVDImpl
    /**
     * @for LinearAlgebra
     * @method jacobiSVDImpl
     * @private
     * @static
     *
     * @param {Matrix_t} At
     * @param {number} astep
     * @param {Matrix_t} _W
     * @param {Matrix_t} Vt
     * @param {number} vstep
     * @param {number} m
     * @param {number} n
     * @param {number} n1
     * @constructor
     */
    function jacobiSVDImpl ( At, astep, _W, Vt, vstep, m, n, n1 ) {

      var eps = Igata.EPSILON * 2.0;
      var minval = Igata.FLT_MIN;
      var i=0,j=0,k=0,iter=0,max_iter=_max(m, 30);
      var Ai=0,Aj=0,Vi=0,Vj=0,changed=0;
      var c=0.0, s=0.0, t=0.0;
      var t0=0.0,t1=0.0,sd=0.0,beta=0.0,gamma=0.0,delta=0.0,a=0.0,p=0.0,b=0.0;
      var seed = 0x1234;
      var val=0.0,val0=0.0,asum=0.0;

      var W_buff = Cache.getBuffer(n&lt;&lt;3);
      var W = W_buff.f64;

      for (; i &lt; n; i++) {

        for (k = 0, sd = 0; k &lt; m; k++) {

          t = At[i*astep + k];
          sd += t*t;

        }

        W[i] = sd;

        if (Vt) {

          for (k = 0; k &lt; n; k++) {

            Vt[i*vstep + k] = 0;

          }

          Vt[i*vstep + i] = 1;

        }

      }

      for (; iter &lt; max_iter; iter++) {
        changed = 0;

        for (i = 0; i &lt; n-1; i++) {

          for (j = i+1; j &lt; n; j++) {

            Ai = (i*astep)|0;
            Aj = (j*astep)|0;

            a = W[i];
            p = 0;
            b = W[j];

            k = 2;
            p += At[Ai]*At[Aj];
            p += At[Ai+1]*At[Aj+1];

            for (; k &lt; m; k++) {

              p += At[Ai+k]*At[Aj+k];

            }

            if ( _abs(p) &lt;= eps*_sqrt(a*b) ) {

              continue;

            }

            p *= 2.0;
            beta = a - b;
            gamma = hypot(p, beta);

            if ( beta &lt; 0 ) {

              delta = (gamma - beta)*0.5;
              s = _sqrt(delta/gamma);
              c = (p/(gamma*s*2.0));

            } else {

              c = _sqrt((gamma + beta)/(gamma*2.0));
              s = (p/(gamma*c*2.0));

            }

            a=0.0;
            b=0.0;

            k = 2; // unroll
            t0 = c*At[Ai] + s*At[Aj];
            t1 = -s*At[Ai] + c*At[Aj];

            At[Ai] = t0;
            At[Aj] = t1;

            a += t0*t0;
            b += t1*t1;

            t0 = c*At[Ai+1] + s*At[Aj+1];
            t1 = -s*At[Ai+1] + c*At[Aj+1];
            At[Ai+1] = t0;
            At[Aj+1] = t1;

            a += t0*t0;
            b += t1*t1;

            for ( ; k &lt; m; k++ ) {

              t0 = c*At[Ai+k] + s*At[Aj+k];
              t1 = -s*At[Ai+k] + c*At[Aj+k];
              At[Ai+k] = t0; At[Aj+k] = t1;

              a += t0*t0; b += t1*t1;

            }

            W[i] = a; W[j] = b;

            changed = 1;

            if ( Vt) {

              Vi = (i*vstep)|0;
              Vj = (j*vstep)|0;

              k = 2;
              t0 = c*Vt[Vi] + s*Vt[Vj];
              t1 = -s*Vt[Vi] + c*Vt[Vj];
              Vt[Vi] = t0;
              Vt[Vj] = t1;

              t0 = c*Vt[Vi+1] + s*Vt[Vj+1];
              t1 = -s*Vt[Vi+1] + c*Vt[Vj+1];
              Vt[Vi+1] = t0;
              Vt[Vj+1] = t1;

              for (; k &lt; n; k++) {

                t0 = c*Vt[Vi+k] + s*Vt[Vj+k];
                t1 = -s*Vt[Vi+k] + c*Vt[Vj+k];
                Vt[Vi+k] = t0;
                Vt[Vj+k] = t1;

              }

            }

          }

        }

        if (changed === 0) {

          break;

        }

      }

      for (i = 0; i &lt; n; i++) {

        for (k = 0, sd = 0; k &lt; m; k++) {

          t = At[i*astep + k];
          sd += t*t;

        }

        W[i] = _sqrt(sd);

      }

      for (i = 0; i &lt; n-1; i++) {

        j = i;

        for (k = i+1; k &lt; n; k++) {

          if ( W[j] &lt; W[k]){

            j = k;

          }

        }

        if ( i !== j) {

          swap(W, i, j, sd);

          if ( Vt) {

            for (k = 0; k &lt; m; k++) {

              swap(At, i*astep + k, j*astep + k, t);

            }

            for (k = 0; k &lt; n; k++) {

              swap(Vt, i*vstep + k, j*vstep + k, t);

            }

          }

        }

      }

      for (i = 0; i &lt; n; i++) {

        _W[i] = W[i];

      }

      if ( !Vt) {

        Cache.putBuffer(W_buff);
        return;

      }

      for (i = 0; i &lt; n1; i++) {

        sd = i &lt; n ? W[i] : 0;

        while(sd &lt;= minval) {

          // if we got a zero singular value, then in order to get the corresponding left singular vector
          // we generate a random vector, project it to the previously computed left singular vectors,
          // subtract the projection and normalize the difference.
          val0 = (1.0/m);

          for (k = 0; k &lt; m; k++) {

            seed = (seed * 214013 + 2531011);
            val = (((seed &gt;&gt; 16) &amp; 0x7fff) &amp; 256) !== 0 ? val0 : -val0;
            At[i*astep + k] = val;

          }

          for (iter = 0; iter &lt; 2; iter++) {

            for (j = 0; j &lt; i; j++) {

              sd = 0;

              for (k = 0; k &lt; m; k++) {

                sd += At[i*astep + k]*At[j*astep + k];

              }

              asum = 0.0;

              for (k = 0; k &lt; m; k++) {

                t = (At[i*astep + k] - sd*At[j*astep + k]);
                At[i*astep + k] = t;
                asum += _abs(t);

              }

              asum = asum ? 1.0/asum : 0;

              for (k = 0; k &lt; m; k++) {

                At[i*astep + k] *= asum;

              }

            }

          }

          sd = 0;

          for (k = 0; k &lt; m; k++) {

            t = At[i*astep + k];
            sd += t*t;

          }

          sd = _sqrt(sd);

        }

        s = (1.0/sd);

        for (k = 0; k &lt; m; k++) {

          At[i*astep + k] *= s;

        }

      }

      Cache.putBuffer(W_buff);

    }

    // ---------------------------------------------------
    // class
    // ---------------------------------------------------
    /**
     * @class LinearAlgebra
     * @static
     * @constructor
     */
    function LinearAlgebra () {
      throw new Error( &#x27;LinearAlgebra can\&#x27;t create instance.&#x27; );
    }

    var p = LinearAlgebra.prototype;
    p.constructor = LinearAlgebra;

    /**
     * A and B modified and result output in B
     *
     * Solves the system of linear equations Ax = B using Cholesky factorization. The matrix must be symmetrical and positively defined. NOTE: input matrix_t instances will be modified and result output in matrix B.
     *
     * @method lu_solve
     * @static
     * @param {Matrix_t} A
     * @param {Matrix_t} B
     * @return {number}
     */
    LinearAlgebra.lu_solve = function ( A, B ) {

      var i=0,j=0,k=0,p=1,astep=A.cols;
      var ad=A.data, bd=B.data;
      var t,alpha,d,s;

      for (i = 0; i &lt; astep; i++) {

        k = i;

        for (j = i+1; j &lt; astep; j++) {

          if ( Math.abs(ad[j*astep + i]) &gt; Math.abs(ad[k*astep+i])) {

            k = j;

          }

        }

        if ( _abs(ad[k*astep+i]) &lt; Igata.EPSILON ) {

          // FAILED
          return 0;

        }

        if ( k !== i) {

          for (j = i; j &lt; astep; j++ ) {

            swap(ad, i*astep+j, k*astep+j, t);

          }

          swap(bd, i, k, t);
          p = -p;

        }

        d = -1.0/ad[i*astep+i];

        for (j = i+1; j &lt; astep; j++) {

          alpha = ad[j*astep+i]*d;

          for (k = i+1; k &lt; astep; k++) {

            ad[j*astep+k] += alpha*ad[i*astep+k];

          }

          bd[j] += alpha*bd[i];

        }

        ad[i*astep+i] = -d;

      }

      for (i = astep-1; i &gt;= 0; i--) {

        s = bd[i];

        for (k = i+1; k &lt; astep; k++) {

          s -= ad[i*astep+k]*bd[k];

        }

        bd[i] = s*ad[i*astep+i];

      }

      // OK
      return 1;

    };
    /**
     * A and B modified and result output in B
     *
     * Solves the system of linear equations Ax = B using Cholesky factorization. The matrix must be symmetrical and positively defined. NOTE: input matrix_t instances will be modified and result output in matrix B.
     *
     * @method cholesky_solve
     * @static
     * @param {Matrix_t} A
     * @param {Matrix_t} B
     * @return {number}
     */
    LinearAlgebra.cholesky_solve = function ( A, B ) {

      var col=0,row=0,col2=0,cs=0,rs=0,i=0,j=0;
      var size = A.cols;
      var ad=A.data, bd=B.data;
      var val,inv_diag;

      for (col = 0; col &lt; size; col++) {

        inv_diag = 1.0;
        cs = (col * size);
        rs = cs;

        for (row = col; row &lt; size; row++) {

          // correct for the parts of cholesky already computed
          val = ad[(rs+col)];

          for (col2 = 0; col2 &lt; col; col2++) {

            val -= ad[(col2*size+col)] * ad[(rs+col2)];

          }

          if (row === col) {
            // this is the diagonal element so don&#x27;t divide
            ad[(rs+col)] = val;

            if ( val === 0) {

              return 0;

            }

            inv_diag = 1.0 / val;

          } else {

            // cache the value without division in the upper half
            ad[(cs+row)] = val;
            // divide my the diagonal element for all others
            ad[(rs+col)] = val * inv_diag;

          }

          rs = (rs + size);

        }

      }

      // first backsub through L
      cs = 0;

      for (i = 0; i &lt; size; i++) {

        val = bd[i];

        for (j = 0; j &lt; i; j++) {

          val -= ad[(cs+j)] * bd[j];

        }

        bd[i] = val;
        cs = (cs + size);

      }
      // backsub through diagonal
      cs = 0;

      for (i = 0; i &lt; size; i++) {

        bd[i] /= ad[(cs + i)];
        cs = (cs + size);

      }

      // backsub through L Transpose
      i = (size-1);

      for (; i &gt;= 0; i--) {

        val = bd[i];
        j = (i + 1);
        cs = (j * size);

        for (; j &lt; size; j++) {

          val -= ad[(cs + i)] * bd[j];
          cs = (cs + size);

        }

        bd[i] = val;

      }

      return 1;

    };
    /**
     * This routine decomposes an rows x cols matrix A, into a product of the three matrices U, W, and V&#x27;, i.e. A = UWV&#x27;, where U is an rows x rows matrix whose columns are orthogonal, W is a 1 x cols matrix, and V is an cols x cols orthogonal matrix.
     *
     * @method svd_decompose
     * @static
     * @param {Matrix_t} A
     * @param {Matrix_t} W vector of singular values
     * @param {Matrix_t} U the left orthogonal matrix
     * @param {Matrix_t} V the right orthogonal matrix
     * @param {number=0} [options] Igata.SVD_U_T and/or Igata.SVD_V_T to return transposed U and/or V
     */
    LinearAlgebra.svd_decompose = function ( A, W, U, V, options ) {

      if (typeof options === &#x27;undefined&#x27;) { options = 0; }

      var at=0,i=0,j=0,_m=A.rows,_n=A.cols,m=_m,n=_n;

      // we only work with single channel
      var dt = A.type | Igata.C1_t;

      if ( m &lt; n) {

        at = 1;
        i = m;
        m = n;
        n = i;

      }

      var a_buff = Cache.getBuffer((m*m)&lt;&lt;3);
      var w_buff = Cache.getBuffer(n&lt;&lt;3);
      var v_buff = Cache.getBuffer((n*n)&lt;&lt;3);

      var a_mt = new Matrix_t(m, m, dt, a_buff.data);
      var w_mt = new Matrix_t(1, n, dt, w_buff.data);
      var v_mt = new Matrix_t(n, n, dt, v_buff.data);

      if ( at === 0) {
        // transpose
        MM.transpose(a_mt, A);

      } else {

        for (i = 0; i &lt; _n*_m; i++) {

          a_mt.data[i] = A.data[i];

        }

        for (; i &lt; n*m; i++) {

          a_mt.data[i] = 0;

        }

      }

      jacobiSVDImpl(a_mt.data, m, w_mt.data, v_mt.data, n, m, n, m);

      if ( W) {

        for (i=0; i &lt; n; i++) {

          W.data[i] = w_mt.data[i];

        }

        for (; i &lt; _n; i++) {

          W.data[i] = 0;

        }

      }

      if (at === 0) {

        if (U &amp;&amp; (options &amp; Igata.SVD_U_T)) {

          i = m*m;

          while(--i &gt;= 0) {

            U.data[i] = a_mt.data[i];

          }

        } else if (U) {

          MM.transpose(U, a_mt);

        }

        if ( V &amp;&amp; (options &amp; Igata.SVD_V_T) ) {

          i = n*n;

          while(--i &gt;= 0) {

            V.data[i] = v_mt.data[i];

          }

        } else if (V) {

          MM.transpose(V, v_mt);

        }

      } else {

        if ( U &amp;&amp; (options &amp; Igata.SVD_U_T)) {

          i = n*n;

          while(--i &gt;= 0) {

            U.data[i] = v_mt.data[i];

          }

        } else if ( U) {

          MM.transpose(U, v_mt);

        }

        if (V &amp;&amp; (options &amp; Igata.SVD_V_T)) {

          i = m*m;

          while(--i &gt;= 0) {

            V.data[i] = a_mt.data[i];

          }

        } else if (V) {

          MM.transpose(V, a_mt);

        }

      }

      Cache.putBuffer(a_buff);
      Cache.putBuffer(w_buff);
      Cache.putBuffer(v_buff);

    };
    /**
     * Solves the system of linear equations Ax = B using Singular value decomposition (SVD) method; the system can be over-defined and/or the matrix A can be singular.
     *
     * @method svd_solve
     * @static
     * @param {Matrix_t} A left-hand side of the system
     * @param {Matrix_t} X right-hand side of the system
     * @param {Matrix_t} B output solution
     */
    LinearAlgebra.svd_solve = function(A, X, B) {

      var i=0,j=0,k=0;
      var pu=0,pv=0;
      var nrows=A.rows,ncols=A.cols;
      var sum=0.0,xsum=0.0,tol=0.0;
      var dt = A.type | Igata.C1_t;

      var u_buff = Cache.getBuffer((nrows*nrows)&lt;&lt;3);
      var w_buff = Cache.getBuffer(ncols&lt;&lt;3);
      var v_buff = Cache.getBuffer((ncols*ncols)&lt;&lt;3);

      var u_mt = new Matrix_t(nrows, nrows, dt, u_buff.data);
      var w_mt = new Matrix_t(1, ncols, dt, w_buff.data);
      var v_mt = new Matrix_t(ncols, ncols, dt, v_buff.data);

      var bd = B.data, ud = u_mt.data, wd = w_mt.data, vd = v_mt.data;

      LinearAlgebra.svd_decompose(A, w_mt, u_mt, v_mt, 0);

      tol = Igata.EPSILON * wd[0] * ncols;

      for (; i &lt; ncols; i++, pv += ncols) {

        xsum = 0.0;

        for (j = 0; j &lt; ncols; j++) {

          if (wd[j] &gt; tol) {

            for (k = 0, sum = 0.0, pu = 0; k &lt; nrows; k++, pu += ncols) {

              sum += ud[pu + j] * bd[k];

            }

            xsum += sum * vd[pv + j] / wd[j];

          }

        }

        X.data[i] = xsum;

      }

      Cache.putBuffer(u_buff);
      Cache.putBuffer(w_buff);
      Cache.putBuffer(v_buff);

    };

    /**
     * @method svd_invert
     * @static
     * @param {Matrix_t} Ai
     * @param {Matrix_t} A
     */
    LinearAlgebra.svd_invert = function (Ai, A) {
      
      var i=0,j=0,k=0;
      var pu=0,pv=0,pa=0;
      var nrows=A.rows,ncols=A.cols;
      var sum=0.0,tol=0.0;
      var dt = A.type | Igata.C1_t;

      var u_buff = Cache.getBuffer((nrows*nrows)&lt;&lt;3);
      var w_buff = Cache.getBuffer(ncols&lt;&lt;3);
      var v_buff = Cache.getBuffer((ncols*ncols)&lt;&lt;3);

      var u_mt = new Matrix_t(nrows, nrows, dt, u_buff.data);
      var w_mt = new Matrix_t(1, ncols, dt, w_buff.data);
      var v_mt = new Matrix_t(ncols, ncols, dt, v_buff.data);

      var id = Ai.data, ud = u_mt.data, wd = w_mt.data, vd = v_mt.data;

      LinearAlgebra.svd_decompose(A, w_mt, u_mt, v_mt, 0);

      tol = Igata.EPSILON * wd[0] * ncols;

      for (; i &lt; ncols; i++, pv += ncols) {

        for (j = 0, pu = 0; j &lt; nrows; j++, pa++) {

          for (k = 0, sum = 0.0; k &lt; ncols; k++, pu++) {

            if (wd[k] &gt; tol) {

              sum += vd[pv + k] * ud[pu] / wd[k];

            }

          }

          id[pa] = sum;

        }

      }

      Cache.putBuffer(u_buff);
      Cache.putBuffer(w_buff);
      Cache.putBuffer(v_buff);

    };

    /**
     * Computes eigenvalues and eigenvectors of a symmetric matrix.
     *
     *      LinearAlgebra.eigenVV(A:matrix_t, EigenVectors:matrix_t, EigenValues:matrix_t);
     *
     *      // you can ask for Vectors or Values only
     *      LinearAlgebra.eigenVV(A:matrix_t, null, EigenValues:matrix_t);
     *
     *      LinearAlgebra.eigenVV(A:matrix_t, EigenVectors:matrix_t, null);
     *
     * @method eigenVV
     * @static
     * @param {Matrix_t} A
     * @param {Matrix_t} [vects]
     * @param {Matrix_t} [vals]
     */
    LinearAlgebra.eigenVV = function(A, vects, vals) {

      var n=A.cols,i=n*n;
      var dt = A.type | Igata.C1_t;

      var a_buff = Cache.getBuffer((n*n)&lt;&lt;3);
      var w_buff = Cache.getBuffer(n&lt;&lt;3);

      var a_mt = new Matrix_t(n, n, dt, a_buff.data);
      var w_mt = new Matrix_t(1, n, dt, w_buff.data);

      while(--i &gt;= 0) {

        a_mt.data[i] = A.data[i];

      }

      jacobiImpl(a_mt.data, n, w_mt.data, vects ? vects.data : null, n, n);

      if ( vals) {

        while(--n &gt;= 0) {

          vals.data[n] = w_mt.data[n];

        }

      }

      Cache.putBuffer(a_buff);
      Cache.putBuffer(w_buff);

    };

    return LinearAlgebra;

  }() );

  global.LinearAlgebra = LinearAlgebra;
  /**
   * alias LinearAlgebra
   *
   * @class LA
   * @uses LinearAlgebra
   */
  global.LA = LinearAlgebra;

}( window ) );
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
